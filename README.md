# Project 500: A Minimal ARM64 Kernel

A clean, minimal operating system kernel written from scratch for AArch64 (ARMv8-A) using QEMU.  
Includes UART logging, stack setup, physical memory management, virtual memory mapping, MMU activation, context switching, and exception handling.


**Current Status: This project is currently in its foundational development stage. The Philosophy.md document establishes the intellectual framework and long-term vision, while the current codebase builds the essential technical infrastructure needed to eventually demonstrate these concepts.

**Researchers interested in adversarial OS design, trust boundaries, or system subversion are invited to initiate technical dialogue or collaboration.


For debugging blogs, Q&A, please visit: https://medium.com/@xzt0202 


Future Roadmap(generalized version):

Phase 4: File System and Storage
	â€¢	Implement a RAM-based filesystem (tmpfs-like).
	â€¢	Add support for basic file operations (open, read, write, close).
	â€¢	Begin building a persistent storage backend (simple EXT2-like structures).

Phase 5: User Management and Process Isolation
	â€¢	Implement user authentication and account management.
	â€¢	Enforce user-space vs kernel-space privilege separation.
	â€¢	Strengthen process isolation to prevent unauthorized memory access.

Phase 6: Networking and Basic Security
	â€¢	Build a basic TCP/IP networking stack.
	â€¢	Add rudimentary network encryption for communication security.
	â€¢	Prepare infrastructure for multi-process and remote interactions.


Research Platform Expansion

Pegasus-Class APT Simulation and Defense

This project will evolve into a kernel-level research testbed capable of simulating Pegasus-style Advanced Persistent Threats (APTs) within a custom-built ARM64 operating system.

Phase 2A: Implant Simulation
	â€¢	Simulate stealth implant delivery via syscall injection or rogue process spawning.
	â€¢	Model privilege escalation via corrupted syscall tables or page mappings.
	â€¢	Build persistence mechanisms across reboots via injected hooks or init hijacking.
	â€¢	Emulate data exfiltration channels through UART and memory scanning.
	â€¢	Implement anti-forensics techniques such as self-deletion and memory unlinking.

Phase 2B: OS-Level Defenses
	â€¢	Syscall Trace Monitor to detect anomalous syscall flows.
	â€¢	Memory Integrity Zones enforced via page table protections and MMU traps.
	â€¢	Secure Logging Kernel (append-only in-memory logs protected against tampering).
	â€¢	Heuristic-based behavioral engine to detect suspicious transitions and persistence attempts.
	â€¢	Emergency Containment Protocols to isolate compromised processes or trigger safe reboots.

Phase 2C: Experimental Evaluation
	â€¢	Attack Chain Graphs to visualize multi-stage APT behavior (drop â†’ escalate â†’ persist â†’ exfiltrate).
	â€¢	Threat Model document describing attacker assumptions and TCB boundaries.
	â€¢	Evaluation Matrix to measure detection speed, containment time, and system impact.
	â€¢	Research Abstract framing this work for potential workshop or conference submission.


Long-Term Vision

This platform will serve as:
	â€¢	A low-level systems security research environment.
	â€¢	A teaching and experimentation tool for OS security concepts.
	â€¢	A reproducible framework for studying real-world attack models and defense strategies.

Work will continue toward memory integrity enforcement, syscall verification, containment protocols, and formal verification of critical subsystems.

## Features

### Core Architecture
- Bootable from QEMU `virt` machine using `kernel8.img`
- Custom linker script and assembly bootstrap (`start.S`)
- Stack setup with proper alignment and mapping
- UART driver (PL011) with output before and after MMU enablement

### Memory Management
- Physical page allocator (bitmap-backed)
- Virtual memory manager with full L0â€“L3 page table support
- **MMU enablement with robust transition handling:**
  - Identity mapping for execution continuity
  - Vector table mapping with VBAR_EL1 pre-update
  - Executable permission (PXN/UXN) management
  - Safe context switching between address spaces

### Task Management
- Task structure with register state storage
- Context switching with full register state preservation
- Supervisor call (SVC) handling for system services
- EL0 (user mode) task support

### Debugging Infrastructure
- Comprehensive exception handling with diagnostic output
- Debug logging via UART with formatted hex output
- Memory permission verification
- Stack alignment checking

## Project Structure
```
CustomOS
â”œâ”€â”€ boot/
â”‚   â”œâ”€â”€ linker.ld            # Kernel linker script
â”‚   â””â”€â”€ start.S              # Boot assembly code
â”œâ”€â”€ kernel/
â”‚   â”œâ”€â”€ context.S            # Context switching code
â”‚   â”œâ”€â”€ interrupts.c         # Interrupt handling
â”‚   â”œâ”€â”€ main.c               # Kernel entry point
â”‚   â”œâ”€â”€ scheduler.c          # Task scheduling
â”‚   â”œâ”€â”€ serror_debug_handler.S # System error debug handler
â”‚   â”œâ”€â”€ string.c             # String manipulation utilities
â”‚   â”œâ”€â”€ syscall.c            # System call implementation
â”‚   â”œâ”€â”€ task.c               # Task management
â”‚   â”œâ”€â”€ timer.c              # System timer implementation
â”‚   â”œâ”€â”€ trap.c               # Exception handlers
â”‚   â”œâ”€â”€ uart_early.c         # Early boot UART driver
â”‚   â”œâ”€â”€ uart_late.c          # Post-MMU UART driver
â”‚   â”œâ”€â”€ user.S               # User mode support
â”‚   â”œâ”€â”€ user_entry.c         # User task entry points
â”‚   â””â”€â”€ vector.S             # Exception vector table
â”œâ”€â”€ memory/
â”‚   â”œâ”€â”€ pmm.c                # Physical memory manager
â”‚   â””â”€â”€ vmm.c                # Virtual memory manager
â”œâ”€â”€ include/
â”‚   â”œâ”€â”€ debug.h              # Debugging utilities
â”‚   â”œâ”€â”€ interrupts.h         # Interrupt declarations
â”‚   â”œâ”€â”€ kernel.h             # Kernel-wide definitions
â”‚   â”œâ”€â”€ pmm.h                # Physical memory declarations
â”‚   â”œâ”€â”€ scheduler.h          # Scheduler declarations
â”‚   â”œâ”€â”€ string.h             # String utilities
â”‚   â”œâ”€â”€ syscall.h            # System call definitions
â”‚   â”œâ”€â”€ task.h               # Task management declarations
â”‚   â”œâ”€â”€ timer.h              # Timer declarations
â”‚   â”œâ”€â”€ types.h              # Common type definitions
â”‚   â”œâ”€â”€ uart.h               # UART driver interface
â”‚   â””â”€â”€ vmm.h                # Virtual memory declarations
â””â”€â”€ scripts/
    â”œâ”€â”€ run_debug.sh         # Run with GDB debugging
    â”œâ”€â”€ run_gui_mode.sh      # Run with QEMU GUI
    â”œâ”€â”€ run_monitor_telnet.sh # Run with monitor over telnet
    â”œâ”€â”€ run_nographic.sh     # Run in nographic mode
    â”œâ”€â”€ run_serial_file.sh   # Run with serial output to file
    â””â”€â”€ run_serial_stdio.sh  # Run with serial output to stdio
```

## ðŸ›  Build Instructions

### Dependencies
- `qemu-system-aarch64`
- `aarch64-elf-gcc` cross toolchain

### Build and Run

```bash
make
qemu-system-aarch64 -M virt -cpu cortex-a53 -nographic -kernel build/kernel8.img
```


## Recent Fixes and Improvements

### MMU UART String Output Fix

The UART string output issues after MMU enablement have been resolved with a comprehensive approach:

1. **Global String Buffers**: Added global static buffers (aligned to cache lines) for safe string storage during MMU transition.

2. **Improved Cache Maintenance**: Implemented explicit cache line cleaning/invalidation with proper barriers for UART strings.

3. **TLB Invalidation**: Fixed TLB invalidation with proper inner-shareable domain instructions (`tlbi vmalle1is` instead of `tlbi vmalle1`).

4. **Memory Barriers**: Enhanced synchronization with proper barriers (DSB ISH, ISB) across all critical MMU transitions.

5. **Emergency UART Functions**: Added assembly-based UART access functions that bypass normal C code hazards.

6. **Hardened String Handling**: Modified string output functions to use global buffers and guard against dereference hazards.

7. **UART MMIO Mapping**: Improved UART device memory mapping with explicit cache maintenance and TLB invalidation.

8. **Diagnostic Capabilities**: Added extensive diagnostic output during the MMU transition for debugging.



## Build Instructions

```
make clean
make
```

## Running

The OS can be run on the Raspberry Pi 3/4 or in QEMU.

### QEMU

For QEMU with debugging:

```
qemu-system-aarch64 -M raspi3 -kernel build/kernel8.img -serial stdio -s -S
```

For QEMU without debugging:

```
qemu-system-aarch64 -M raspi3 -kernel build/kernel8.img -serial stdio
```

```
aarch64-elf-gdb build/kernel.elf -ex "target remote localhost:1234"
```